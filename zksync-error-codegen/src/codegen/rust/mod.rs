pub mod config;
pub mod error;
pub mod files;

use config::RustBackendConfig;
use error::GenerationError;

use crate::codegen::printer::PrettyPrinter;
use crate::model::error::ModelError;
use crate::model::ComponentDescription;
use crate::model::DomainDescription;
use crate::model::ErrorDescription;
use crate::model::FieldDescription;
use crate::model::FullyQualifiedTargetLanguageType;
use crate::model::Model;

use super::Backend;
use super::File;

pub struct RustBackend {
    model: Model,
}

impl Backend<RustBackendConfig> for RustBackend {
    type Error = GenerationError;

    fn get_name() -> &'static str {
        "rust"
    }

    fn generate(&mut self, _config: &RustBackendConfig) -> Result<Vec<File>, Self::Error> {
        Ok(vec![
            self.generate_error_definitions()?,
            self.generate_domains()?,
        ])
    }

    fn get_language_name() -> &'static str {
        "rust"
    }
}

impl RustBackend {
    pub fn new(model: Model) -> Self {
        Self { model }
    }

    fn preamble(file: &mut PrettyPrinter) {
        let string = r#"
//!
//! AUTOGENERATED FROM JSON FILE, DO NOT EDIT MANUALLY
//!
"#;
        file.push_str(string);
    }

    fn type_as_rust(typ: &FullyQualifiedTargetLanguageType) -> String {
        let FullyQualifiedTargetLanguageType { name, path } = typ;
        if path.is_empty() {
            format!("{name}")
        } else {
            format!("{path}.{name}")
        }
    }

    fn get_rust_type(&self, name: &str) -> Result<String, GenerationError> {
        let typ = self.model.get_type(Self::get_language_name(), name)?;
        Ok(Self::type_as_rust(typ))
    }

    fn error_field<'a>(&self, field: &FieldDescription) -> Result<String, GenerationError> {
        let FieldDescription { name, r#type } = field;
        let rust_type = self.get_rust_type(r#type)?;

        Ok(format!("{name} : {rust_type},"))
    }

    fn error_kind<'a>(&self, error: &ErrorDescription) -> Result<String, GenerationError> {
        let ErrorDescription {
            name, code, fields, ..
        } = error;
        let mut result = PrettyPrinter::new(1024);
        result.push_line(&format!("{name} {{ "));
        result.indent_increase();
        for field in fields {
            result.push_line(&self.error_field(field)?);
        }
        result.indent_decrease();

        result.push_line(&format!("}} = {code}, "));
        Ok(result.get_buffer())
    }

    fn error_kind_match<'a>(
        &self,
        component: &ComponentDescription,
        error: &ErrorDescription,
    ) -> Result<String, GenerationError> {
        let component_name = Self::component_type_name(component)?;
        let ErrorDescription { name, fields, .. } = error;
        let mut result = PrettyPrinter::default();

        result.push_line(&format!("{component_name}::{name} {{ "));

        result.indent_increase();
        for field in fields {
            let field_name = &field.name;
            result.push_line(&format!("{field_name},"));
        }
        result.indent_decrease();

        result.push_line(&format!("}}"));
        Ok(result.get_buffer())
    }

    fn component_type_name(component: &ComponentDescription) -> Result<String, GenerationError> {
        let name = component
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelError::UnmappedName(component.name.clone()))?;

        Ok(format!("{name}Error"))
    }
    fn component_code_type_name(
        component: &ComponentDescription,
    ) -> Result<String, GenerationError> {
        let name = component
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelError::UnmappedName(component.name.clone()))?;

        Ok(format!("{name}ComponentCode"))
    }

    fn error_type_name(error: &ErrorDescription) -> Result<String, GenerationError> {
        let name = &error
            .bindings
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelError::UnmappedName(error.name.clone()))?
            .name;

        Ok(format!("{name}Error"))
    }

    fn domain_type_name(domain: &DomainDescription) -> Result<String, GenerationError> {
        let name = domain
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelError::UnmappedName(domain.name.clone()))?;

        Ok(format!("{name}Error"))
    }

    fn domain_code_type_name(domain: &DomainDescription) -> Result<String, GenerationError> {
        let name = domain
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelError::UnmappedName(domain.name.clone()))?;

        Ok(format!("{name}ErrorCode"))
    }
}
/*

use strum_macros::EnumDiscriminants;

use crate::error_definitions::RustSDKError;
use crate::error_definitions::RustSDKErrorCode;
use crate::error_definitions::SolcError;
use crate::error_definitions::SolcErrorCode;
use crate::error_definitions::ZksolcError;
use crate::error_definitions::ZksolcErrorCode;

#[repr(i32)]
#[derive(Clone, Debug, EnumDiscriminants, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum ZksyncError {
    CompilerError(CompilerError),
    ToolingError(ToolingError),
}

impl ZksyncError {
    pub fn get_kind(&self) -> zksync_error::kind::Kind {
        match self {
            ZksyncError::CompilerError(compiler_error) => Kind::Compiler(match compiler_error {
                CompilerError::Zksolc(_) => CompilerComponent::Zksolc,
                CompilerError::Solc(_) => CompilerComponent::Solc,
            }),
            ZksyncError::ToolingError(tooling_error) => Kind::Tooling(match tooling_error {
                ToolingError::RustSDK(_) => ToolingComponent::RustSDK,
            }),
        }
    }
    pub fn get_code(&self) -> i32 {
        match self {
            ZksyncError::CompilerError(compiler_error) => match compiler_error {
                CompilerError::Zksolc(zksolc_error) => {
                    Into::<ZksolcErrorCode>::into(zksolc_error) as i32
                }
                CompilerError::Solc(solc_error) => Into::<SolcErrorCode>::into(solc_error) as i32,
            },
            ZksyncError::ToolingError(tooling_error) => match tooling_error {
                ToolingError::RustSDK(rust_sdkerror) => {
                    Into::<RustSDKErrorCode>::into(rust_sdkerror) as i32
                }
            },
        }
    }
}
impl IUnifiedError<ZksyncError> for ZksyncError {}

#[derive(Clone, Debug, EnumDiscriminants, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(CompilerSubdomainCode))]
#[strum_discriminants(vis(pub))]
pub enum CompilerError {
    Zksolc(ZksolcError),
    Solc(SolcError),
}

#[derive(Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ToolingSubdomainCode))]
#[strum_discriminants(vis(pub))]
pub enum ToolingError {
    RustSDK(RustSDKError),
}

impl ICustomError<ZksyncError, ZksyncError> for ZksolcError {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::CompilerError(CompilerError::Zksolc(self.clone()))
    }
}
impl ICustomError<ZksyncError, ZksyncError> for SolcError {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::CompilerError(CompilerError::Solc(self.clone()))
    }
}
impl ICustomError<ZksyncError, ZksyncError> for RustSDKError {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::ToolingError(ToolingError::RustSDK(self.clone()))
    }
}

impl std::fmt::Display for ZksyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{:#?}", self))
    }
}
impl std::error::Error for ZksyncError {}

*/
